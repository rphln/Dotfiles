#!/usr/bin/python3

"""
I made an `autojump` clone. After experimenting a bit with fuzzy matching and whatnot, I
settled on something that is ultimately fairly simple, but predictable. And in my
experience, being predictable is extremely valuable for for this type of tool, otherwise
it just gets in my way.

The whole thing is a SQLite table with a `path` and an `expires` column and a bunch of
Python functions. The most complex part it has is the expiration timer, based on
Firefox's [frecency], but that is mostly invisible in daily use. Finding the best
matches is done by querying a directory by returning the shortest matching existing path
which is not expired. The reasoning for this is as follows:

1.  Matching the shortest path works nicely, as I can always be more specific in my
    query to go deeper. This would not be an option if we were to match the longest path
    instead. Fuzzy matching simply did not feel *good* to use.
2.  Entries expires after a while. This prevents the jumper from getting filled with
    clutter which I don't care about anymore. Again, see [frecency] for more details on
    how it works.
3.  The pattern should be obtained trivially and intuitively: using `j a /b/ c d` yields
    `%a%/b/%c%d%`. We got exact sub-path matching for free.

  [frecency]: https://wiki.mozilla.org/User:Jesse/NewFrecency?title=User:Jesse/NewFrecency
"""

import sqlite3
from datetime import timedelta
from functools import partial
from json import dumps
from math import exp, log
from os.path import exists
from pathlib import Path
from time import time

# TODO: Switch to `argparse` to reduce dependencies.
import click

# TODO: Use logging.

# Each visit has a half-life of a week by default.
HALF_LIFE = timedelta(days=14).total_seconds()
DECAY_RATE = log(2) / HALF_LIFE

DEFAULT_PATH = Path("~/.local/share/jump.sqlite3").expanduser()


def s_to_t(s: float, now: float) -> float:
    """
    Converts a positive score to a timestamp. The timestamp indicates when the score will reach `1`.
    """

    return now + log(s) / DECAY_RATE


def t_to_s(t: float, now: float) -> float:
    """
    Converts a timestamp to a score.
    """

    return exp((t - now) * DECAY_RATE)


# TODO: Make this not global.
connection = None


@click.group()
@click.option("--database", type=Path, default=DEFAULT_PATH)
def main(database):
    global connection

    now = time()
    connection = sqlite3.connect(database.resolve())

    connection.create_function("s_to_t", 1, partial(s_to_t, now=now))
    connection.create_function("t_to_s", 1, partial(t_to_s, now=now))

    connection.create_function("is_folder", 1, exists)


@main.command()
def init():
    global connection

    SCRIPT = """
    CREATE TABLE IF NOT EXISTS `visits` (
      `path` TEXT PRIMARY KEY,
      `expires` NUMERIC
    );
    """

    with connection:
        connection.execute(SCRIPT)


@main.command()
@click.argument("path")
def record(path):
    global connection

    SCRIPT = """
    INSERT INTO `visits`
        (`path`, `expires`)
    VALUES
        (:path, s_to_t(2))
    ON CONFLICT (`path`) DO
        UPDATE SET `expires` = s_to_t(t_to_s(`expires`) + 2);
    """

    with connection:
        connection.execute(SCRIPT, {"path": path})


@main.command()
@click.argument("path")
def forget(path):
    global connection

    SCRIPT = """
    DELETE FROM
        `visits`
    WHERE
        `path` = :path
    """

    with connection:
        connection.execute(SCRIPT, {"path": path})


@main.command()
@click.argument("pattern", nargs=-1)
@click.option("--count", default=1)
@click.option(
    "--json",
    is_flag=True,
    default=False,
    help="Render the output as JSONL.",
)
@click.option(
    "--show-deleted",
    is_flag=True,
    default=False,
    help="Whether to show or hide deleted folders.",
)
@click.option(
    "--show-stale",
    is_flag=True,
    default=False,
    help="Whether to show or hide stale folders.",
)
def query(pattern, count, json, show_deleted, show_stale):
    """
    Returns the shortest matching path.
    """

    global connection

    SCRIPT = """
    SELECT
        `path`,
        t_to_s(`expires`) AS `score`,
        is_folder(`path`) AS `is_valid`
    FROM
        `visits`
    WHERE
        `path` LIKE "%" || :pattern || "%"
        AND (:show_stale OR `score` >= 1)
        AND (:show_deleted OR `is_valid`)
    ORDER BY
        LENGTH(`path`)
    LIMIT
        :count;
    """

    pattern = "%".join(pattern)

    with connection:
        context = {
            "pattern": pattern,
            "count": count,
            "show_deleted": show_deleted,
            "show_stale": show_stale,
        }
        cursor = connection.execute(SCRIPT, context)

        for (path, score, is_valid) in cursor:
            row = {
                "path": path,
                "score": score,
                "is_valid": is_valid,
            }

            if json:
                print(dumps(row))
            else:
                print(path)


if __name__ == "__main__":
    main()
