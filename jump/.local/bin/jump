#!/usr/bin/env python3

import sqlite3
from datetime import datetime, timedelta
from functools import partial
from itertools import islice
from json import dumps
from math import exp, log
from os.path import exists
from pathlib import Path
from time import time

# TODO: Switch to `argparse` to reduce dependencies.
import click

# TODO: Use logging.


HALF_LIFE = timedelta(days=7).total_seconds()
DECAY_RATE = log(2) / HALF_LIFE

SIGMA = 8

DEFAULT_PATH = Path("~/.cache/jump.sqlite3").expanduser()


def similarity(a, b):
    return exp(-0.5 * ((len(a) - len(b)) / SIGMA) ** 2)


def s_to_t(s: float, now: float) -> float:
    """
    Converts a positive score to a timestamp. The timestamp indicates when the score will reach `1`.
    """

    return now + log(s) / DECAY_RATE


def t_to_s(t, now):
    """
    Converts a timestamp to a score.
    """

    return exp((t - now) * DECAY_RATE)


# TODO: Make this not global.
connection = None


@click.group()
@click.option("--database", type=Path, default=DEFAULT_PATH)
def main(database):
    global connection

    now = time()
    connection = sqlite3.connect(database.resolve())

    connection.create_function("s_to_t", 1, partial(s_to_t, now=now))
    connection.create_function("t_to_s", 1, partial(t_to_s, now=now))
    connection.create_function("similarity", 2, similarity)


@main.command()
def init():
    global connection

    SCRIPT = """
    CREATE TABLE IF NOT EXISTS `visits` (
      `path` TEXT PRIMARY KEY,
      `expires` NUMERIC
    );
    """

    with connection:
        connection.execute(SCRIPT)


@main.command()
@click.argument("path")
def record(path):
    global connection

    SCRIPT = """
    INSERT INTO `visits`
        (`path`, `expires`)
    VALUES
        (:path, s_to_t(1))
    ON CONFLICT (`path`) DO
        UPDATE SET `expires` = s_to_t(t_to_s(`expires`) + 1);
    """

    with connection:
        connection.execute(SCRIPT, {"path": path})


@main.command()
@click.argument("path")
def forget(path):
    global connection

    SCRIPT = """
    DELETE FROM
        `visits`
    WHERE
        `path` = :path
    """

    with connection:
        connection.execute(SCRIPT, {"path": path})


@main.command()
@click.argument("query", nargs=-1)
@click.option("--count", default=1)
@click.option("--json/--no-json", default=False)
@click.option("--show-invalid/--hide-invalid", default=False)
def query(query, count, json, show_invalid):
    global connection

    SCRIPT = """
    SELECT
        `path`,
        `expires`,
        t_to_s(`expires`) AS `score`,
        similarity(`path`, :query) AS `similarity`
    FROM
        `visits`
    WHERE
        `path` LIKE "%" || :query || "%"
    ORDER BY
        `similarity` * `score` DESC;
    """

    query = "%".join(query)

    with connection:
        for (path, expires, score, similarity) in islice(
            connection.execute(SCRIPT, {"query": query}), count
        ):
            if not show_invalid and not exists(path):
                continue

            if json:
                row = {
                    "score": score,
                    "similarity": similarity,
                    "expires": datetime.fromtimestamp(expires).isoformat(),
                    "path": path,
                }
                print(dumps(row))
            else:
                print(path)


if __name__ == "__main__":
    main()
