#!/usr/bin/python3

import sqlite3
from datetime import timedelta
from functools import partial
from json import dumps
from math import exp, log
from os.path import exists
from pathlib import Path
from time import time

# TODO: Switch to `argparse` to reduce dependencies.
import click

# TODO: Use logging.

# Each visit has a half-life of a week by default.
HALF_LIFE = timedelta(days=14).total_seconds()
DECAY_RATE = log(2) / HALF_LIFE

DEFAULT_PATH = Path("~/.cache/jump.sqlite3").expanduser()


def s_to_t(s: float, now: float) -> float:
    """
    Converts a positive score to a timestamp. The timestamp indicates when the score will reach `1`.
    """

    return now + log(s) / DECAY_RATE


def t_to_s(t: float, now: float) -> float:
    """
    Converts a timestamp to a score.
    """

    return exp((t - now) * DECAY_RATE)


# TODO: Make this not global.
connection = None


@click.group()
@click.option("--database", type=Path, default=DEFAULT_PATH)
def main(database):
    global connection

    now = time()
    connection = sqlite3.connect(database.resolve())

    connection.create_function("s_to_t", 1, partial(s_to_t, now=now))
    connection.create_function("t_to_s", 1, partial(t_to_s, now=now))

    connection.create_function("is_folder", 1, exists)


@main.command()
def init():
    global connection

    SCRIPT = """
    CREATE TABLE IF NOT EXISTS `visits` (
      `path` TEXT PRIMARY KEY,
      `expires` NUMERIC
    );
    """

    with connection:
        connection.execute(SCRIPT)


@main.command()
@click.argument("path")
def record(path):
    global connection

    SCRIPT = """
    INSERT INTO `visits`
        (`path`, `expires`)
    VALUES
        (:path, s_to_t(2))
    ON CONFLICT (`path`) DO
        UPDATE SET `expires` = s_to_t(t_to_s(`expires`) + 2);
    """

    with connection:
        connection.execute(SCRIPT, {"path": path})


@main.command()
@click.argument("path")
def forget(path):
    global connection

    SCRIPT = """
    DELETE FROM
        `visits`
    WHERE
        `path` = :path
    """

    with connection:
        connection.execute(SCRIPT, {"path": path})


@main.command()
@click.argument("pattern", nargs=-1)
@click.option("--count", default=1)
@click.option(
    "--json",
    is_flag=True,
    default=False,
    help="Render the output as JSON.",
)
@click.option(
    "--show-missing",
    is_flag=True,
    default=False,
    help="Whether to show or hide deleted folders.",
)
@click.option(
    "--show-expired",
    is_flag=True,
    default=False,
    help="Whether to show or hide expired folders.",
)
def query(pattern, count, json, show_missing, show_expired):
    """
    Returns the shortest matching path.
    """

    global connection

    SCRIPT = """
    SELECT
        `path`,
        t_to_s(`expires`) AS `score`,
        is_folder(`path`) AS `is_valid`
    FROM
        `visits`
    WHERE
        `path` LIKE "%" || :pattern || "%"
        AND (:show_expired OR `score` >= 1)
        AND (:show_missing OR `is_valid`)
    ORDER BY
        LENGTH(`path`)
    LIMIT
        :count;
    """

    pattern = "%".join(pattern)

    with connection:
        context = {
            "pattern": pattern,
            "count": count,
            "show_missing": show_missing,
            "show_expired": show_expired,
        }
        cursor = connection.execute(SCRIPT, context)

        for (path, score, is_valid) in cursor:
            row = {
                "path": path,
                "score": score,
                "is_valid": is_valid,
            }

            if json:
                print(dumps(row))
            else:
                print(path)


if __name__ == "__main__":
    main()
